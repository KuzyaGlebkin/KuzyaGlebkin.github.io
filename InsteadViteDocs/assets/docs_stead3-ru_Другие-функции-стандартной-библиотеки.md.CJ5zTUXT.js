import{_ as l,c as s,o as p,ag as a}from"./chunks/framework.BDwTZuFy.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/stead3-ru/Другие-функции-стандартной-библиотеки.md","filePath":"docs/stead3-ru/Другие-функции-стандартной-библиотеки.md"}'),e={name:"docs/stead3-ru/Другие-функции-стандартной-библиотеки.md"};function n(t,i,h,o,k,r){return p(),s("div",null,i[0]||(i[0]=[a(`<h2 id="другие-функции-стандартнои-библиотеки" tabindex="-1">Другие функции стандартной библиотеки <a class="header-anchor" href="#другие-функции-стандартнои-библиотеки" aria-label="Permalink to &quot;Другие функции стандартной библиотеки&quot;">​</a></h2><p>В INSTEAD в модуле stdlib, который всегда подключается автоматически, определены функции, которые предлагаются автору как основной рабочий инструмент по работе с миром игры. Рассмотрим их в этой главе.</p><p>При описании функции в большинстве функций под параметром &#39;w&#39; понимается объект или комната, заданная именем, тегом или по переменной-ссылке. [ wh ] - означает необязательный параметр.</p><ul><li><p>include(файл) - включить файл в игру;</p><pre><code>  include &quot;lib&quot; -- включит файл lib.lua из текущего каталога с игрой;
</code></pre></li><li><p>loadmod(модуль) - подключить модуль игры;</p><pre><code>  loadmod &quot;module&quot; -- включит модуль module.lua из текущего каталога;
</code></pre></li><li><p>rnd(m) - случайное целочисленное значение от &#39;1&#39; до &#39;m&#39;;</p></li><li><p>rnd(a, b) - случайное целочисленное значение от &#39;a&#39; до &#39;b&#39;, где &#39;a&#39; и &#39;b&#39; целые &gt;= 0;</p></li><li><p>rnd_seed(что) - задать зерно генератора случайных чисел;</p></li><li><p>p(...) - вывод строки в буфер обработчика/атрибута (с пробелом в конце);</p></li><li><p>pr(...) - вывод строки в буфер обработчика/атрибута &quot;как есть&quot;;</p></li><li><p>pn(...) - вывод строки в буфер обработчика/атрибута (с переводом строки в конце);</p></li><li><p>pf(fmt, ...) - вывод форматной строки в буфер обработчика/атрибута;</p><pre><code>  local text = &#39;hello&#39;;
  pf(&quot;Строка: %q Число: %d\\n&quot;, text, 10);
</code></pre></li><li><p>pfn(...)(...)... &quot;строка&quot; - формирование простого обработчика; Данная функция упрощает создание простых обработчиков:</p><pre><code>  act = pfn(walk, &#39;ванная&#39;) &quot;Я решил зайти в ванную.&quot;;
  act = pfn(enable, &#39;#переход&#39;) &quot;Я заметил отверстие в стене!&quot;;
</code></pre></li><li><p>obj {} - создание объекта;</p></li><li><p>stat {} - создание статуса;</p></li><li><p>room {} - создание комнаты;</p></li><li><p>menu {} - создание меню;</p></li><li><p>dlg {} - создание диалога;</p></li><li><p>me() - возвращает текущего игрока;</p></li><li><p>here() - возвращает текущую сцену;</p></li><li><p>from([w]) - возвращает комнату из которой осуществлён переход в текущую сцену;</p></li><li><p>new(конструктор, аргументы) - создание нового <em>динамического</em> объекта (будет описано далее);</p></li><li><p>delete(w) - удаление динамического объекта;</p></li><li><p>gamefile(файл, [сбросить состояние?]) - подгрузить динамически файл с игрой;</p><pre><code>  gamefile(&quot;part2.lua&quot;, true) -- сбросить состояние игры (удалить
  объекты и переменные), подгрузить part2.lua и начать с main комнаты.
</code></pre></li><li><p>player {} - создать игрока;</p></li><li><p>dprint(...) - отладочный вывод;</p></li><li><p>visits([w]) - число визитов в данную комнату (или 0, если визитов не было);</p></li><li><p>visited([w]) - число визитов в комнату или false, если визитов не было;</p><pre><code>  if not visited() then
  	p [[Я тут первый раз.]]
  end
</code></pre></li><li><p>walk(w, [булевое exit], [булевое enter], [булевое менять from]) - переход в сцену;</p><pre><code>  walk(&#39;конец&#39;, false, false) -- безусловный переход (игнорировать
  onexit/onenter/exit/enter);
</code></pre></li><li><p>walkin(w) - переход в под-сцену (без вызова exit/onexit текущей комнаты);</p></li><li><p>walkout([w], [dofrom]) - возврат из подсцены (без вызова enter/onenter);</p></li><li><p>walkback([w]) - синоним walkout([w], false);</p></li><li><p>_(w) - получение объекта;</p></li><li><p>for_all(fn, ...) - выполнить функцию для всех аргументов;</p><pre><code>  for_all(enable, &#39;окно&#39;, &#39;дверь&#39;);
</code></pre></li><li><p>seen(w, [где]) - поиск видимого объекта;</p></li><li><p>lookup(w, [где]) - поиск объекта;</p></li><li><p>ways([где]) - получить список переходов;</p></li><li><p>objs([где]) - получить список объектов;</p></li><li><p>search(w) - поиск доступного игроку объекта;</p></li><li><p>have(w) - поиск предмета в инвентаре;</p></li><li><p>inroom(w) - возврат комнаты/комнат, в которой находится объект;</p></li><li><p>where(w, [таблица]) - возврат объекта/объектов, в котором находится объект;</p><pre><code>  local list = {}
  local w = where(&#39;яблоко&#39;, list)
  -- если яблоко находится в более, чем одном месте, то
  -- list будет содержать массив этих мест.
  -- Если вам достаточно одного местоположения, то:
  where &#39;яблоко&#39; -- будет достаточно
</code></pre></li><li><p>closed(w) - true если объект закрыт;</p></li><li><p>disabled(w) - true если объект выключен;</p></li><li><p>enable(w) - включить объект;</p></li><li><p>disable(w) - выключить объект;</p></li><li><p>open(w) - открыть объект;</p></li><li><p>close(w) - закрыть объект;</p></li><li><p>actions(w, строка, [значение]) - возвращает (или устанавливает) число действий типа t для объекта w.</p><pre><code>  if actions(w, &#39;tak&#39;) &gt; 0 then -- предмет w был взят хотя бы 1 раз;
  if actions(w) == 1 then -- act у предмета w был вызван 1 раз;
</code></pre></li><li><p>pop(тег) - возврат в прошлую ветвь диалога;</p></li><li><p>push(тег) - переход в следующую ветвь диалога</p></li><li><p>empty([w]) - пуста ли ветвь диалога? (или объект)</p></li><li><p>lifeon(w) - добавить объект в список живых;</p></li><li><p>lifeoff(w) - убрать объект из списка живых;</p></li><li><p>live(w) - объект жив?;</p></li><li><p>change_pl(w) - смена игрока;</p></li><li><p>player_moved([pl]) - текущий игрок перемещался в этом такте?;</p></li><li><p>inv([pl]) - получить список-инвентарь;</p></li><li><p>remove(w, [wh]) - удалить объект из объекта или комнаты; Удаляет объект из списков obj и way (оставляя во всех остальных, например, game.lifes);</p></li><li><p>purge(w) - уничтожить объект (из всех списков); удаляет объект из <em>всех</em> списков, в которых он присутствует;</p></li><li><p>replace(w, ww, [wh]) - заменить один объект на другой;</p></li><li><p>place(w, [wh]) - поместить объект в объект/комнату (удалив его из старого объекта/комнаты);</p></li><li><p>put(w, [wh]) - поместить объект без удаления из старого местоположения;</p></li><li><p>take(w) - забрать объект;</p></li><li><p>drop(w, [wh]) - выбросить объект;</p></li><li><p>path {} - создать переход;</p></li><li><p>time() - число ходов от начала игры.</p></li></ul><p><strong>Важно!</strong></p><p>На самом деле, многие из этих функций также умеют работать не только с комнатами и объектами, но и со списками. То есть &#39;remove(apple, inv())&#39; сработает также как и &#39;remove(apple, me())&#39;&#39;; Впрочем, remove(apple) тоже сработает и удалит объект из тех мест, где он присутствует.</p><p>Рассмотрим несколько примеров.</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">act</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	pn</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Я иду в следующую комнату...&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	walk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nextroom);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	nam </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;моя машина&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	dsc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Перед хижиной стоит мой старенький {пикап} Toyota.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	act</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		walk</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;inmycar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p><strong>Важно!</strong></p><blockquote><p>После вызова &#39;walk&#39; выполнение обработчика продолжится до его завершения. Поэтому обычно, после &#39;walk&#39; всегда следует &#39;return&#39;, если только это не последняя строка функции, хотя и в этом случае безопасно поставить &#39;return&#39;.</p></blockquote><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">act</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        pn</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Я иду в следующую комнату...&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        walk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nextroom);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>Не забывайте также, что при вызове &#39;walk&#39; вызовутся обработчики &#39;onexit/onenter/exit/enter&#39;&#39; и если они запрещают переход, то он не произойдёт.</p>`,12)]))}const u=l(e,[["render",n]]);export{c as __pageData,u as default};

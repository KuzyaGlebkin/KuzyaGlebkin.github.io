import{_ as i,c as a,o as t,ag as n}from"./chunks/framework.BDwTZuFy.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/modules3-ru/Примеры-модулей/Модуль-клавиатурного-ввода.md","filePath":"docs/modules3-ru/Примеры-модулей/Модуль-клавиатурного-ввода.md"}'),k={name:"docs/modules3-ru/Примеры-модулей/Модуль-клавиатурного-ввода.md"};function h(l,s,p,e,d,E){return t(),a("div",null,s[0]||(s[0]=[n(`<h3 id="модуль-клавиатурного-ввода" tabindex="-1">Модуль клавиатурного ввода <a class="header-anchor" href="#модуль-клавиатурного-ввода" aria-label="Permalink to &quot;Модуль клавиатурного ввода&quot;">​</a></h3><p>В качестве следующего примера рассмотрим код модуля keyboard. Этот модуль можно скачать с <a href="https://github.com/instead-hub/stead3-modules/tree/master/keyboard" target="_blank" rel="noreferrer">репозитория модулей</a>. Модуль позволяет организовать ввод пользователя с клавиатуры.</p><p>Идея модуля состоит в том, что клавиатурный ввод оформлен в виде специальной комнаты, в которой можно выполнить набор текста и вернуться к первоначальной комнате.</p><p>Комната, содержащая в себе логику клавиатурного ввода, носит имя @keyboard. Это системный объект, который не уничтожается при рестарте мира.</p><p>Для использования клавиатуры используется ссылка на системный объект (см. main3.lua):</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> [[Как вас {@keyboard &quot;Имя&quot;|зовут}?]]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>Как видим, в качестве параметра передаётся информационная строка, которая будет отображена при вводе.</p><p>Объект @keyboard, соответственно, должен реализовать act обработчик, который перенесёт игрока в комнату клавиатурного ввода:</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	act</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, w, ...)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">title</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">or</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;?&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		walkin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>Кроме того, что здесь мы меняем название комнаты (title) и делаем переход (walkin), мы также запомнили все дополнительные аргументы, если они передавались в ссылке {@keyboard}. Зачем это нужно, будет ясно позднее.</p><p>Итак, осталось реализовать клавиатурный ввод. Для этого мы воспользуемся ссылками кнопок (для того, чтобы вводить текст можно было на устройствах без клавиатуры). И одновременно с этим, будем отслеживать нажатия на клавиши с помощью модуля keys (для удобства игроков на компьютерах с клавиатурой).</p><p>Формирование ссылок-клавиш осуществляется в decor. При этом, ссылки формируются в виде:</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">row </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> row</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;{@kbdinput &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;|&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">input_esc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;}&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">..</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fmt.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nb</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;  &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>input_esc() -- функция, реализованная в модуле, которая экранирует некоторые символы, типа { и }.</p><p>Как видим, это снова ссылки на системный объект, но теперь это уже @kbdinput. Этот объект специально создан для обработки событий от клавиш. Прежде чем мы перейдём к нему, рассмотрим вопрос использования модуля keys.</p><p>Для использования keys мы должны:</p><ul><li>определить onkey в комнате @keyboard;</li><li>задать keys:filter()</li></ul><p>Мы могли бы просто определить в модуле:</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- логика функции</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>Но мы хотим, чтобы наш модуль мог работать совместно с каким-то другим применением модуля keys, поэтому при старте игры мы перехватываем старый обработчик keys:filter, заменяя его на свой. А потом, при деинициализации мира возвращаем старый обработчик обратно (когда он уже не нужен).</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hooked</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orig_filter</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">std.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mod_start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(load)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hooked </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		hooked </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		orig_filter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> std.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rawget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(keys, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;filter&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		std.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rawset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(keys, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;filter&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, std.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hook</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(keys.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, s, press, key)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> std.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">here</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keyboard_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> then</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">				return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hook_keys[key]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, press, key)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">std.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mod_done</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(load)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	hooked </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	std.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rawset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(keys, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;filter&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, orig_filter)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Здесь мы видим использование нескольких функций:</p><ul><li>std.rawget(таблица, имя) - получить элемент таблицы без генерации сообщения о несуществующей переменой (работа с переменными на низком уровне);</li><li>std.rawset(таблица, имя, значение) - установить значение элемента таблицы без генерации сообщения о необъявленной переменной;</li><li>std.hook(старая функция, функция перехвата) - создать функцию перехвата.</li></ul><p>std.rawget/std.rawset -- это способ работы с переменными на самом низком уровне. Например, если бы в mod_start мы просто присвоили keys.filter = std.hook ..., то мы получили бы сообщение о том, что мы меняем объект, который не является переменной.</p><p>Итак, если клавиши нажимаются в момент нахождения в комнате @keyboard, то мы используем наш фильтр клавиш, если нет -- используется перехваченный фильтр клавиш (keys:filter).</p><p>Массив hook_keys содержит все те клавиши, которые мы перехватываем.</p><p>Объект @kbdinput реализует act, который занимается обработкой вводимых символов. Когда текст набран и ввод подтверждён клавишей ввод или соответствующей ссылкой выполняется следующий код:</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">walkback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> std.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(std.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">here</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;onkbd&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@keyboard&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, std.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">unpack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@keyboard&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>Как видим, происходит вызов обработчика onkbd в комнате из которой мы пришли. В качестве первого параметра передаётся введённый текст. Затем передаются все те параметры, которые пользователь задал в ссылке @keyboard. Эти параметры помогут идентифицировать поле ввода, если мы хотим использовать несколько полей ввода в одной комнате.</p><p>Здесь используются следующие функции:</p><ul><li>std.unpack(таблица) -- превратить таблицу в набор аргументов;</li><li>std.call(объект, метод, аргументы) -- вызвать обработчик объекта instead.</li></ul><p>Теперь вы можете самостоятельно разобраться в остальных деталях модуля @keyboard.</p>`,32)]))}const y=i(k,[["render",h]]);export{g as __pageData,y as default};

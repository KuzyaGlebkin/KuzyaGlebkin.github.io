import{_ as a,c as i,o as e,ag as n}from"./chunks/framework.BDwTZuFy.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/modules3-ru/Игровой-мир.md","filePath":"docs/modules3-ru/Игровой-мир.md"}'),t={name:"docs/modules3-ru/Игровой-мир.md"};function p(l,s,h,k,r,d){return e(),i("div",null,s[0]||(s[0]=[n(`<h2 id="игровои-мир" tabindex="-1">Игровой мир <a class="header-anchor" href="#игровои-мир" aria-label="Permalink to &quot;Игровой мир&quot;">​</a></h2><p>Важным отличием модуля от просто библиотечного файла является время жизни модуля. Игровой мир (объект game, игрок, все объекты и переменные игры) создаётся в момент запуска игры. При подгрузке частей игры с помощью gamefile, а также при загрузке сохранений игры -- игровой мир уничтожается, чтобы затем снова создаться заново. В момент уничтожения мира, все созданные объекты и переменные перестают существовать.</p><p>Когда вы включаете код с помощью include, весь этот код будет выполнятся в момент каждого создания мира. Обычно, это подразумевается автором как само собой разумеющееся поведение. Но в случае модуля, это не так!</p><p>Модуль загружается один раз, во время создания игровой сессии и существует всё то время, пока выполняется игровой код. То есть, после уничтожении игрового мира и при его новом создании, уже загруженные ранее модули не загружаются повторно.</p><p>Это означает, например, что в модуле <em>нельзя</em> определять глобальные переменные, объекты и комнаты так, как это делается в обычном коде игры. Например, модуль не может содержать строки вида:</p><pre><code>-- мой неправильный модуль
global &#39;MYVAR&#39; (10);
room { nam = &#39;комната&#39;; };
</code></pre><p>Дело в том, что и MYVAR и комната будут уничтожены при первой же загрузки игры из файла сохранения, так как игровой мир уничтожается целиком, а переменная MYVAR и комната -- часть этого игрового мира.</p><p>Если подумать, это становится понятным с той точки зрения, что модуль не должен в общем случае создавать какие-то объекты и глобальные переменные в игровом мире игры. Ведь модуль может работать с любой игрой, и не должен учитывать особенности игрового мира конкретной игры.</p><p>Создание глобальных функций тоже не является хорошим тоном при написании модулей. Если вам нужна служебная функция в рамках самого модуля, объявляйте её с local (то же касается и переменных):</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myfunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>Тогда такая функция будет доступна в рамках модуля.</p>`,11)]))}const _=a(t,[["render",p]]);export{c as __pageData,_ as default};
